# sec-primitives

**THIS IS AN EDUCATIONAL PROJECT. DO NOT USE IT**

This crate contains crypto primitives, which are part of laboratory work on the subject of "Software and data security systems".

Right now it contains:
- [x] Primes generation
- [x] RSA {en|de}cryption with OAEP-SHA256 padding
- [x] ECDSA signing/verification
- [x] Hybrid encryption

## Tests

There is some number of tests for each primitive. I think it would be expanded in the future, but by know try:

```bash
$ cargo test
```

## Examples

### Prime generation

```rust
use sec_primitives::prime::{gen, ver};

// Generate 256-bit prime
let prime = gen::new_prime(256);

// Check for primeness with miller-rabin test
assert!(ver::is_prime(&prime));
```

### RSA

Due to the fact, that cryptography should be _boring_, only secure (well, in theory) encryption with OAEP-SHA256 padding is supported.

```rust
use sec_primitives::rsa::generate_rsa_pair;

let data = b"my fancy data";
let (public, private) = generate_rsa_pair(1024).unwrap();
let mut rng = rand::thread_rng();
let ciphertext = public.encrypt_oaep_sha256(&mut rng, data).unwrap();
let plaintext = private.decrypt_oaep_sha256(&ciphertext).unwrap();
assert_eq!(plaintext, data);
```

### ECDSA

ECDSA signatures are supported. To use them, you should choose the elliptic curve (currently only P256 is supported).

```rust
use sec_primitives::ecdsa::{curves, PrivateKey};

let params = &curves::P256;
let data = "ðŸ‘¾";
let signer = PrivateKey::random(params);

let sig = signer.sign(rand::thread_rng(), data.as_bytes());
let verifier = signer.public_key();

let result = verifier.verify(data.as_bytes(), &sig);
assert!(result.is_ok());
```

### Cell
Cell represents an object, which can encrypt and decrypt data with a simple API using symmetric cryptography.

Under the hood the AES-GCM-256 is used. Nonce is generated by secure RNG and stored together with ciphertext.

```rust
use sec_primitives::cell::{CellKey, Cell};
let key = CellKey::random();
let cell = Cell::new(&key);
let msg = b"secure cell";

let encrypted = cell.encrypt(msg).unwrap();
let decrypted = cell.decrypt(&encrypted).unwrap();
assert_eq!(decrypted, msg);
```

### Letter
The Letter represents the object, that allows communication with a use of hybrid cryptography. It encrypts message with a sender's private key and receiver's public key, so that only the receiver, that knows the sender's key, could decrypt the message.

Under the hood:
1) It derives shared secret from asymmetric keys using the ECDH key exchange.
2) It derives symmetric key from the shared secret
3) The letter encrypts the message using the Cell.

```rust
use sec_primitives::{
    ecdsa::{curves, PrivateKey, PublicKey},
    letter::Letter
};

let curve = &curves::P256;

let alice = PrivateKey::random(curve);
let bob = PrivateKey::random(curve);

// The key that alice will send to bob
let alice_pub = alice.public_key();
// The key that bob will send to alice
let bob_pub = bob.public_key();

// This what the alice would do
let alice_to_bob = Letter::new(&alice, &bob_pub).unwrap();
// This what the bob would do
let bob_to_alice = Letter::new(&bob, &alice_pub).unwrap();

let msg = "It was me who ate the cake";

// bob encrypts and sends message to the alice
let encrypted_letter = bob_to_alice.encrypt(msg.as_bytes()).unwrap();

// alice decrypt the message from the bob
let decrypted_letter = alice_to_bob.decrypt(&encrypted_letter).unwrap();

assert_eq!(decrypted_letter, msg.as_bytes());
```
